;; Collateral Vault Puzzle enables XCH to be locked and BYC to be minted based on XCH price.
;; This main puzzle controls creation and recreation of the coin and different run modes for the vault, since it can
;; be run by the owner or keepers. It also enforces strict lineage.
;; Owner operations available for the coin are:
;; - deposit collateral
;; - withdraw collateral
;; - borrow BYC (create debt)
;; - repay BYC (extinguish debt)
;; - transfer (new inner puzzle)
;; Keeper operations available for the coin are:
;; - start liquidation auction
;; - bid in liquidation auction
;; - recover bad debt
;; - transfer fees to treasury


(mod ((OWNER_OPERATIONS . KEEPER_OPERATIONS) MOD_HASH STATUTES_STRUCT COLLATERAL PRINCIPAL
      AUCTION_STATE INNER_PUZZLE_HASH DISCOUNTED_PRINCIPAL
      (
        lineage_proof
        ; owner mode iff keeper_operation_info is nil
        inner_puzzle
        solution ; normal solution for inner puzzle, usually a list of conditions, must include vault operation condition
        ; the following keeper operations can be performed:
        ; - transfer stability fees
        ; - (re-)start auction
        ; - bid
        ; - recover bad debt
        keeper_operation_info
      )
     )

  (include *standard-cl-23.1*)
  (include curry.clib)
  (include condition_codes.clib)
  (include utils.clib)
  (include condition_filtering.clib)
  (include prefixes.clib)
  (include statutes_utils.clib)

  ; fails on create coin
  ; fails on protocol conditions other than remark
  ; fails if not exactly one protocol remark encountered
  ; returns body of protocol remark condition and filtered conditions
  (defun filter-and-extract-unique-protocol-remark ((@ conditions ((condition_code . condition_body) . rest_of_conditions)) found_remark filtered_conditions)
    (if conditions
      (if (= condition_code CREATE_COIN)
        (x) ; no CREATE_COIN allowed
        (if (= condition_code REMARK)
          (if (is-valid-rmk-cond condition_body)
            ; non-protocol remarks are fine
            (filter-and-extract-unique-protocol-remark rest_of_conditions found_remark (c (f conditions) filtered_conditions))
            ; protocol remark
            (if found_remark
              (x) ; only one protocol remark allowed
              (filter-and-extract-unique-protocol-remark rest_of_conditions (r condition_body) filtered_conditions)
            )
          )
          (if (any (= condition_code SEND_MESSAGE) (= condition_code RECEIVE_MESSAGE))
            (assert
              (is-valid-msg-cond condition_body)
              (filter-and-extract-unique-protocol-remark rest_of_conditions found_remark (c (f conditions) filtered_conditions))
            )
            (if (any (= condition_code CREATE_COIN_ANNOUNCEMENT) (= condition_code CREATE_PUZZLE_ANNOUNCEMENT))
              (assert
                (is-valid-ann-cond condition_body)
                (filter-and-extract-unique-protocol-remark rest_of_conditions found_remark (c (f conditions) filtered_conditions))
              )
              ; all other conditions allowed
              (filter-and-extract-unique-protocol-remark rest_of_conditions found_remark (c (f conditions) filtered_conditions))
            )
          )
        )
      )
      (assert
        found_remark
        (list found_remark filtered_conditions)
      )
    )
  )

  (defun-inline operation-program (operation)
    (f (r operation))
  )

  (assign
    statutes_struct_hash (sha256tree STATUTES_STRUCT)
    conditions (a inner_puzzle solution)
    inner_puzzle_hash (sha256tree inner_puzzle)
    keeper_operation_info (if (= inner_puzzle_hash INNER_PUZZLE_HASH) () conditions)
    (vault_operation_condition filtered_conditions) (filter-and-extract-unique-protocol-remark conditions () ())
    (statutes_inner_puzzle_hash vault_operation . args) vault_operation_condition
    statutes_puzzle_hash (calculate-statutes-puzzle-hash
      (c (f STATUTES_STRUCT) statutes_struct_hash)
      statutes_inner_puzzle_hash
    )
    vault_operation_hash (sha256tree vault_operation)
    (
      (
        final_collateral_amount
        final_principal_amount
        final_auction_state
        final_inner_puzzle_hash
        final_discounted_principal
      )
      operation_conditions
    ) (a
      vault_operation
      (list
        (list COLLATERAL PRINCIPAL AUCTION_STATE INNER_PUZZLE_HASH
              STATUTES_STRUCT DISCOUNTED_PRINCIPAL statutes_puzzle_hash inner_puzzle_hash)
        args
      )
    )
    inner_conditions (merge-lists filtered_conditions operation_conditions)
    ;### MAIN EXPRESSION ###
    (assert
      (size_b32 final_inner_puzzle_hash)
      (if keeper_operation_info
        ; keeper mode
        (contains KEEPER_OPERATIONS vault_operation_hash)
        ; owner mode
        (all
          (not AUCTION_STATE)
          (= inner_puzzle_hash INNER_PUZZLE_HASH)
          (contains OWNER_OPERATIONS vault_operation_hash)
        )
      )
      (c
        (list CREATE_COIN_ANNOUNCEMENT
          (concat
            PROTOCOL_PREFIX
            (sha256tree (list STATUTES_STRUCT inner_puzzle_hash))
          )
        ) ; for fee coin
        (c
          (list CREATE_COIN
            (curry_hashes MOD_HASH
              (sha256tree MOD_HASH)
              statutes_struct_hash
              (sha256 ONE final_collateral_amount)
              (sha256 ONE final_principal_amount)
              (sha256tree final_auction_state)
              (sha256 ONE final_inner_puzzle_hash)
              (sha256 ONE final_discounted_principal)
            ) ; puzzle hash
            final_collateral_amount ; amount
            (list final_inner_puzzle_hash) ; memos
          )
          (c
            (list
              ; this is for the driver code to make it easy to generate puzzle reveal
              REMARK
              PROTOCOL_PREFIX
              final_collateral_amount
              final_principal_amount
              final_auction_state
              final_inner_puzzle_hash
              final_discounted_principal
            )
            (if lineage_proof
              (li
                ; verify lineage by calculating parent coin id based on lineage proof
                (list
                  ASSERT_MY_PARENT_ID
                  (coinid
                    (f lineage_proof)
                    (tree_hash_of_apply MOD_HASH (f (r lineage_proof)))
                    (f (r (r lineage_proof)))
                  )
                )
                (list ASSERT_MY_PUZZLEHASH
                  (curry_hashes MOD_HASH
                    (sha256tree MOD_HASH)
                    statutes_struct_hash
                    (sha256 ONE COLLATERAL)
                    (sha256 ONE PRINCIPAL)
                    (sha256tree AUCTION_STATE)
                    (sha256 ONE INNER_PUZZLE_HASH)
                    (sha256 ONE DISCOUNTED_PRINCIPAL)
                  )
                )
                (list ASSERT_MY_AMOUNT COLLATERAL)
                &rest
                inner_conditions
              )
              ; force that every vault needs to start with zero state, ie no BYC minted, no fees transferred, no principal
              ; otherwise launching a vault with pre-existing debt could cause a lot of issues
              (li
                (list ASSERT_MY_PUZZLEHASH
                  (curry_hashes MOD_HASH
                    (sha256tree MOD_HASH)
                    statutes_struct_hash
                    (sha256 ONE 0)
                    (sha256 ONE 0)
                    (sha256 ONE ())
                    (sha256 ONE INNER_PUZZLE_HASH)
                    (sha256 ONE 0)
                  )
                )
                (list ASSERT_MY_AMOUNT 0)
                &rest
                inner_conditions
              )
            )
          )
        )
      )
    )
  )
)
