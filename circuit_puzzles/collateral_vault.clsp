;; Collateral Vault Puzzle enables XCH to be locked and BYC to be minted based on XCH price.
;; This main puzzle controls creation and recreation of the coin and different run modes for the vault, since it can
;; be run by the owner or keepers. It also enforces strict lineage.
;; Owner operations available for the coin are:
;; - deposit collateral
;; - withdraw collateral
;; - borrow BYC (create debt)
;; - repay BYC (extinguish debt)
;; - transfer (new inner puzzle)
;; Keeper operations available for the coin are:
;; - start liquidation auction
;; - bid in liquidation auction
;; - recover bad debt
;; - transfer fees to treasury


(mod ((OWNER_OPERATIONS . KEEPER_OPERATIONS) MOD_HASH STATUTES_STRUCT COLLATERAL PRINCIPAL
      AUCTION_STATE INNER_PUZZLE_HASH DISCOUNTED_PRINCIPAL
      (
        lineage_proof
        ; owner mode iff keeper_operation_info is nil
        inner_puzzle
        solution ; normal solution for inner puzzle, usually a list of conditions, must include vault operation condition
        ; the following keeper operations can be performed:
        ; - transfer stability fees
        ; - (re-)start auction
        ; - bid
        ; - recover bad debt
        operation
      )
     )

  (include *standard-cl-23.1*)
  (include curry.clib)
  (include condition_codes.clib)
  (include utils.clib)
  (include condition_filtering.clib)
  (include prefixes.clib)
  (include statutes_utils.clib)


  (defun-inline operation-program (operation)
    (f (r operation))
  )

  (assign
    statutes_struct_hash (sha256tree STATUTES_STRUCT)
    input_conditions (a inner_puzzle solution)
    (vault_operation_condition filtered_conditions) (filter-and-extract-remark-solution input_conditions () ())
    inner_puzzle_hash (sha256tree inner_puzzle)
    (statutes_inner_puzzle_hash vault_operation_hash . args) vault_operation_condition
    statutes_puzzle_hash (calculate-statutes-puzzle-hash
      (c (f STATUTES_STRUCT) statutes_struct_hash)
      statutes_inner_puzzle_hash
    )
    operation_hash (sha256tree operation)
    (
      (
        final_collateral_amount
        final_principal_amount
        final_auction_state
        final_inner_puzzle_hash
        final_discounted_principal
      )
      operation_conditions
    ) (a
      operation
      (list
        (list COLLATERAL PRINCIPAL AUCTION_STATE INNER_PUZZLE_HASH
              STATUTES_STRUCT DISCOUNTED_PRINCIPAL statutes_puzzle_hash inner_puzzle_hash)
        args
      )
    )
    inner_conditions (merge-lists filtered_conditions operation_conditions)
    ;### MAIN EXPRESSION ###
    (assert
      (= operation_hash vault_operation_hash)
      (size_b32 final_inner_puzzle_hash)
      ; validate operation
      (if (contains OWNER_OPERATIONS vault_operation_hash)
        ; owner mode
        (all
          (not AUCTION_STATE)
          (= inner_puzzle_hash INNER_PUZZLE_HASH)
        )
        ; keeper mode
        (contains KEEPER_OPERATIONS vault_operation_hash)
      )
      (c
        (list CREATE_COIN_ANNOUNCEMENT
          (concat
            PROTOCOL_PREFIX
            inner_puzzle_hash
          )
        ) ; for fee coin
        (c
          (list CREATE_COIN
            (curry_hashes MOD_HASH
              (sha256tree MOD_HASH)
              statutes_struct_hash
              (sha256 ONE final_collateral_amount)
              (sha256 ONE final_principal_amount)
              (sha256tree final_auction_state)
              (sha256 ONE final_inner_puzzle_hash)
              (sha256 ONE final_discounted_principal)
            ) ; puzzle hash
            final_collateral_amount ; amount
            (list final_inner_puzzle_hash) ; memos
          )
          (c
            (list
              ; this is for the driver code to make it easy to generate puzzle reveal
              REMARK
              PROTOCOL_PREFIX
              final_collateral_amount
              final_principal_amount
              final_auction_state
              final_inner_puzzle_hash
              final_discounted_principal
            )
            (if lineage_proof
              (li
                ; verify lineage by calculating parent coin id based on lineage proof
                (list
                  ASSERT_MY_PARENT_ID
                  (coinid
                    (f lineage_proof)
                    (tree_hash_of_apply MOD_HASH (f (r lineage_proof)))
                    (f (r (r lineage_proof)))
                  )
                )
                (list ASSERT_MY_PUZZLEHASH
                  (curry_hashes MOD_HASH
                    (sha256tree MOD_HASH)
                    statutes_struct_hash
                    (sha256 ONE COLLATERAL)
                    (sha256 ONE PRINCIPAL)
                    (sha256tree AUCTION_STATE)
                    (sha256 ONE INNER_PUZZLE_HASH)
                    (sha256 ONE DISCOUNTED_PRINCIPAL)
                  )
                )
                (list ASSERT_MY_AMOUNT COLLATERAL)
                &rest
                inner_conditions
              )
              ; force that every vault needs to start with zero state, ie no BYC minted, no fees transferred, no principal
              ; otherwise launching a vault with pre-existing debt could cause a lot of issues
              (li
                (list ASSERT_MY_PUZZLEHASH
                  (curry_hashes MOD_HASH
                    (sha256tree MOD_HASH)
                    statutes_struct_hash
                    (sha256 ONE 0)
                    (sha256 ONE 0)
                    (sha256 ONE ())
                    (sha256 ONE INNER_PUZZLE_HASH)
                    (sha256 ONE 0)
                  )
                )
                (list ASSERT_MY_AMOUNT 0)
                &rest
                inner_conditions
              )
            )
          )
        )
      )
    )
  )
)
