(mod (MOD_HASH CAT_MOD_HASH STATUTES_STRUCT BYC_TAIL_MOD_HASH
      ORACLE_PRICE_ID ; REVIEW: remove ORACLE_PRICE_ID throughout. no longer needed
      TRANSFERRED_FEES
      DEPOSITED_AMOUNT ; REVIEW: rename to COLLATERAL(_AMOUNT)?
      BYC_MINTED_AMOUNT ; REVIEW: rename to PRINCIPAL(_AMOUNT)?
      AUCTION_STATE INNER_PUZZLE_HASH DISCOUNTED_PRINCIPAL
      (
        lineage_proof
        ; normal solution for inner puzzle, usually a list of conditions, must include vault operation condition
        inner_puzzle
        solution
        ; a keeper operation can be run only if vault is under-collateralized
        ; - start auction
        ; - take collateral
        ; - transform to bad debt
        keeper_operation_info
      )
     )

  (include *standard-cl-23*)
  (include curry.clib)
  (include condition_codes.clib)
  (include statutes_utils.clib)
  (include utils.clib)

  (defconst ANN_PREFIX 0x56) ; chr(86) -> "V"

  (defun-inline is-valid-ann-cond (cond_body)
    (not
      (=
        (substr (f cond_body) 0 1)
        ANN_PREFIX
      )
    )
  )

  (defun restrict-conditions ((@ conditions ((condition_code . condition_body) . rest_of_conditions)) found_remark via_solution final_conditions)
  ; RETURNS (conditions vault_operation_condition)
    (if conditions
      (if (= condition_code REMARK)
        (if found_remark
          (x)
          (if (= 'v' (f condition_body)) ; REVIEW: Do we need to use substr here? Deliberately different from ANN_PREFIX ("v" vs "V")? O/w use is-valid-ann-cond?
            (restrict-conditions rest_of_conditions (r condition_body) via_solution final_conditions)
            (x)
          )
        )
        (if via_solution
          (restrict-conditions rest_of_conditions found_remark via_solution (c (f conditions) final_conditions))
          ; keeper mode, only coin announcements are allowed
          (if (any (= condition_code CREATE_COIN_ANNOUNCEMENT) (= condition_code ASSERT_COIN_ANNOUNCEMENT))
            (if (is-valid-ann-cond condition_body)
              (restrict-conditions rest_of_conditions found_remark via_solution (c (f conditions) final_conditions))
              (restrict-conditions rest_of_conditions found_remark via_solution final_conditions)
            )
            ; ignore other conditions if in keeper mode
            (restrict-conditions rest_of_conditions found_remark via_solution final_conditions)
          )
        )
      )
      (list final_conditions found_remark)
    )
  )

  ; filter condition function
  (defun filter-conditions ((@ conditions ((condition_code . condition_body) . rest_of_conditions)) filtered_conditions)
    ; filter out any cheeky announcements, and skip remarks/create coin
    (if conditions
      (if (any (= condition_code CREATE_COIN_ANNOUNCEMENT) (= condition_code CREATE_PUZZLE_ANNOUNCEMENT))
        (if (is-valid-ann-cond condition_body)
          (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
          (filter-conditions rest_of_conditions filtered_conditions)
        )
        (if (any (= condition_code REMARK) (= condition_code CREATE_COIN))
          (filter-conditions rest_of_conditions filtered_conditions)
          (filter-conditions rest_of_conditions (c (f conditions) filtered_conditions))
        )
      )
      filtered_conditions
    )
  )

  (defconst OPERATIONS (list ))

  (defun-inline operation-program (operation)
    (f (r operation))
  )

  (defun-inline operation-treearg (operation)
    (f (r (r operation)))
  )

  (assign
    ; generate tail hash from curried params to avoid any malicious currying
    BYC_TAIL_HASH (curry_hashes BYC_TAIL_MOD_HASH
      (sha256tree STATUTES_STRUCT)
      (sha256 ONE CAT_MOD_HASH)
      (sha256 ONE ORACLE_PRICE_ID)
    )

    raw_conditions (if keeper_operation_info keeper_operation_info (a inner_puzzle solution))
    (conditions_pre vault_operation_condition_pre) (restrict-conditions raw_conditions 0 (not keeper_operation_info) ())
    valid_solution
      (if (all solution (not keeper_operation_info))
        ; owner mode if AUCTION_STATE is empty, ie liquidation hasn't started yet
        (if (all (not AUCTION_STATE) (= (sha256tree inner_puzzle) INNER_PUZZLE_HASH))
          1
          (x)
        )
        ; keeper mode
        (assert keeper_operation_info
          1
        )
      )
    (conditions vault_operation_condition)
      (if (all valid_solution OPERATIONS)
        (assert
          (=
            (sha256tree (operation-program vault_operation_condition_pre))
            (a (operation-treearg vault_operation_condition_pre) OPERATIONS) ; REVIEW: not secure. must ensure only a valid operation can be chosen
          )
          (list conditions_pre vault_operation_condition_pre)
        )
        (list conditions_pre vault_operation_condition_pre)
      )

    (statutes_inner_puzzle_hash vault_operation _ . args) vault_operation_condition
    statutes_puzzle_hash (calculate-statutes-puzzle-hash STATUTES_STRUCT statutes_inner_puzzle_hash)
    (
      (
        final_transferred_fees
        final_xch_deposited_amount
        final_byc_deposited_amount ; REVIEW: rename to final_byc_minted_amount? or even better final_byc_principal and rename BYC_MINTED_AMOUNT accordingly
        final_bids ; REVIEW: rename to final_auction_state?
        final_inner_puzzle_hash
        final_discounted_principal
      )
      vault_conditions
    ) (a
      vault_operation
      (list
        (list DEPOSITED_AMOUNT CAT_MOD_HASH BYC_TAIL_HASH BYC_MINTED_AMOUNT AUCTION_STATE INNER_PUZZLE_HASH
          ORACLE_PRICE_ID STATUTES_STRUCT DISCOUNTED_PRINCIPAL TRANSFERRED_FEES statutes_puzzle_hash)
        args
      )
    )

    inner_conditions (filter-conditions conditions vault_conditions)
    ; WARNING: we should always check that byc minted is above collateral and there is enough collateral
    ; if someone messes with curried params when it's launched, setting BYC minted to a high number, and with very little collateral
    ; then they would be able to liquidate that vault immediately and inflate amount of BYC, but wait!
    ; they would have to provide that BYC to liquidate the vault, so they would have to have that BYC in the first place
    ; bu this still messes up with our accounting and creates under collateralized vaults that messes with our metrics overall
    ; assert lineage
    (c
      (c
        CREATE_COIN ; op code
        (c
          (curry_hashes
            MOD_HASH
            (sha256 ONE MOD_HASH)
            (sha256 ONE CAT_MOD_HASH)
            (sha256tree STATUTES_STRUCT)
            (sha256 ONE BYC_TAIL_MOD_HASH)
            (sha256 ONE ORACLE_PRICE_ID)
            (sha256 ONE final_transferred_fees)
            (sha256 ONE final_xch_deposited_amount) ; REVIEW: Why keep this as curried arg in state if it's also the amount?
            (sha256 ONE final_byc_deposited_amount) ; REVIEW: rename to final_byc_minted_amount (or final_principal) throughout to match curried arg name?
            (sha256tree final_bids)
            (sha256 ONE final_inner_puzzle_hash)
            (sha256 ONE final_discounted_principal)
          ) ; puzzle hash
          (c  final_xch_deposited_amount ; amount
            ; this is a list that forms the create coin condition (using cons), hence double list operator
            (list (list final_inner_puzzle_hash)) ; memos
          )
        )
      )
      (if lineage_proof
        ; verify lineage by calculating parent coin id based on lineage proof
        (c
          (list
            ASSERT_MY_PARENT_ID
              (assign
                ; REVIEW: why include all these state variables in lineage proof instead of just their hash?
                deposited_amount (f (r lineage_proof))
                byc_minted_amount (f (r (r lineage_proof)))
                auction_state (f (r (r (r lineage_proof))))
                inner_puzzle_hash (f (r (r (r (r lineage_proof)))))
                discounted_principal (f (r (r (r (r (r lineage_proof))))))
                transferred_fees (f (r (r (r (r (r (r lineage_proof)))))))
                (calculate-coin-id
                  (f lineage_proof)
                  (curry_hashes
                    MOD_HASH
                    (sha256 ONE MOD_HASH)
                    (sha256 ONE CAT_MOD_HASH)
                    (sha256tree STATUTES_STRUCT)
                    (sha256 ONE BYC_TAIL_MOD_HASH)
                    (sha256 ONE ORACLE_PRICE_ID)
                    (sha256 ONE transferred_fees)
                    (sha256 ONE deposited_amount)
                    (sha256 ONE byc_minted_amount)
                    (sha256tree auction_state)
                    (sha256 ONE inner_puzzle_hash)
                    (sha256 ONE discounted_principal)
                  )
                  deposited_amount
                )
              )
          )
          (c (list ASSERT_MY_AMOUNT DEPOSITED_AMOUNT)
            (c
              (list
                ; this is for driver code to make it easy to generate puzzle reveal
                REMARK
                final_transferred_fees
                final_xch_deposited_amount
                final_byc_deposited_amount
                final_bids
                final_inner_puzzle_hash
                final_discounted_principal
              )
              inner_conditions
            )
          )
        )
        ; force that every vault needs to start with zero state
        ; REVIEW: do we want an unattainable eve state, or are we fine with a vault possibly returning to its eve state?
        (c
          (list
            ASSERT_MY_PUZZLEHASH
            (curry_hashes
              MOD_HASH
              (sha256 ONE MOD_HASH)
              (sha256 ONE CAT_MOD_HASH)
              (sha256tree STATUTES_STRUCT)
              (sha256 ONE BYC_TAIL_MOD_HASH)
              (sha256 ONE ORACLE_PRICE_ID)
              (sha256 ONE 0) 
              (sha256 ONE 0)
              (sha256 ONE 0)
              (sha256 ONE  ())
              (sha256 ONE INNER_PUZZLE_HASH)
              (sha256 ONE 0)
            )
          )
          (c
            (list ASSERT_MY_AMOUNT 0)
            inner_conditions
          )
        )
      )
    )
  )
)