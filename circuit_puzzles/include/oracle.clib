(

  (include prefixes.clib)

  (defun cut-price-infos (price_info_list cutoff last_matured_price_info)
    ;; this function should be called with last_matured_price_info = nil.
    ;;
    ;; returns return_value = (last_matured_price_info (c last_matured_price_info non_matured_price_infos))
    ;; if there is a matured price_info, or (() non_matured_price_infos) otherwise, where
    ;; last_matured_price_info is the matured price_info with greatest (i.e. most recent) timestamp
    ;; and non_matured_price_infos is the list of non-matured price_infos.
    ;;
    ;; if price_info_list is empty, then (() ()) is returned.
    ;; if price_info_list is non-empty, then (r return_value) is not nil, i.e. cutting a
    ;; a non-empty price_info_list will leave at least one (matured or non-matured) price_info
    ;; in the list.
    (if price_info_list
      (if (> cutoff  (r (f price_info_list)))
        (cut-price-infos (r price_info_list) cutoff (f price_info_list))
        (c last_matured_price_info
          (if last_matured_price_info
            (c last_matured_price_info price_info_list)
            price_info_list
          )
        )
      )
      (c last_matured_price_info (list last_matured_price_info))
    )
  )

  (defun fail-on-non-coin-announcement (input_conditions conditions)
    (if input_conditions
      (if
        (any
          ; we only use puzzle announcements, so coin announcements are fine
          (= (f (f input_conditions)) ASSERT_COIN_ANNOUNCEMENT)
          (= (f (f input_conditions)) CREATE_COIN_ANNOUNCEMENT)
        )
        (fail-on-non-coin-announcement (r input_conditions) (c (f input_conditions) conditions))
        (x) ; no other conditions allowed
      )
      conditions
    )
  )

  (defun-inline abs (number)
    (if (> number MINUS_ONE) number (* number MINUS_ONE))
  )

  (defun last-item (lst)
    (if lst
      (if (r lst)
        (last-item (r lst))
        (f lst)
      )
      (x)
    )
  )

  (defun generate-announcer-conditions (
      STATUTES_STRUCT
      ATOM_ANNOUNCER_MOD_HASH
      price_announcers ; -> ((launcher_id args_hash price))
    )
    (if price_announcers
      (assign
        announcer (f price_announcers)
        (launcher_id args_hash price) announcer
        announcer_puzzle_hash (tree_hash_of_apply ATOM_ANNOUNCER_MOD_HASH args_hash)
        ; we don't need to verify that announcer is not expired since it's already checked in announcer puzzle
        (c
          (list ASSERT_PUZZLE_ANNOUNCEMENT
            (sha256
              announcer_puzzle_hash
              PROTOCOL_PREFIX
              (sha256tree
                (c STATUTES_STRUCT (c launcher_id (c ONE price))) ; ONE indicates that announcer is approved
              )
            )
          )
          (c
            (list REMARK launcher_id price)
            (generate-announcer-conditions
              STATUTES_STRUCT
              ATOM_ANNOUNCER_MOD_HASH
              (r price_announcers)
            )
          )
        )
      )
      ()
    )
  )

  (defun list-length (lst count)
    (if lst
      (list-length (r lst) (+ count 1))
      count
    )
  )

  (defun not-contains (lst item)
    (if lst
      (if (= (f (f lst)) item)
        (x)
        (not-contains (r lst) item)
      )
      1
    )
  )

  (defun unique (lst)
    (if (r lst)
      (if (not-contains (r lst) (f (f lst)))
        (unique (r lst))
        (x)
      )
      ONE
    )
  )

  (defun _reverse (L R)
    (if L
      (_reverse
        (r L)
        (c (f L) R)
      )
      R
    )
  )

  (defun-inline endp (L)
    (if L
      (if (r L)
        0
        ONE
      )
      ONE
    )
  )

  (defun _split (Z L R)
    (if (endp R)
        (c (_reverse L ()) Z)
        (_split (r Z) (c (f Z) L) (r (r R))))
    )

  (defun _merge ((@ L ((_ _ L_price) . L_rest)) (@ R ((_ _ R_price) . R_rest)) A)
    (if (any L R)
      (if L
        (if R
          (if (> R_price L_price)
            (_merge L_rest R (c (f L) A))
            (_merge L R_rest (c (f R) A))
          )
          (_merge L_rest () (c (f L) A))
        )
        (_merge () R_rest (c (f R) A))
      )
      (_reverse A ())
    )
  )

  ; thanks @geoff for the mergesort implementation on https://aggsig.me/mergesort.html
  ; takes a list of 3-element lists and returns a list of all 3rd elements in ascending order
  ; by virtue of how _merge function was modified vs original linked above.
  (defun mergesort (Z)
    (if Z
      (if (r Z)
        (assign
          (L . R) (_split Z () Z)
          (_merge (mergesort L) (mergesort R) ())
        )
        Z
      )
      ()
    )
  )

  (defun-inline get-median-index (length)
    ; if odd, we return the middle index. E.g. list length = 3 -> indices = [0 1 2] -> index = 1
    ; if even, we return the larger of the two middle indices: list length = 4 -> indices = [0, 1, 2, 3] -> index = 2
    (/ length TWO)
  )

  (defun get-price (prices index curr_index)
    (if prices
      (if (= index curr_index)
        (f prices)
        (get-price (r prices) index (+ curr_index ONE))
      )
      (x)
    )
  )
)
