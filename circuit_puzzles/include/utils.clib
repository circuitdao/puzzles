(
  (defconst ONE 1)
  (defconst MINUS_ONE -1)
  (defconst TWO 2)
  (defconst MOJOS 1000000000000)
  (defconst PRECISION_PCT 100)
  (defconst PRECISION_BPS 10000)
  (defconst PRICE_PRECISION 100)
  (defconst MAX_TX_BLOCK_TIME 120)
  (defconst PRECISION 10000000000)
  (defconst ONE_MINUTE 60)
  (defconst b32 32)
  (defconst TRUE 1)
  (defconst FALSE ())

  (defun-inline size_b32 (var)
    (= (strlen var) b32)
  )

  (defun and_ (CLAUSES)
    (if (r CLAUSES)
      (qq (if (unquote (f CLAUSES)) (unquote (and_ (r CLAUSES))) ()))
      (f CLAUSES)
      )
    )

  (defmac and CLAUSES (if CLAUSES (and_ CLAUSES) ONE))

  (defun or_ (CLAUSES)
    (if (r CLAUSES) ;; There are more.
      (qq (if (unquote (f CLAUSES)) (unquote (f CLAUSES)) (unquote (or_ (r CLAUSES)))))
      (f CLAUSES)
      )
    )

  (defmac or CLAUSES (if CLAUSES (or_ CLAUSES) ()))


  (defun pow-discount (base exp)
    ;; Exponentiation-by-squaring in fixed point.
    ;; Each multiplication is followed immediately by `/ PRECISION`, preserving
    ;; the same rounding behaviour as applying the factor minute-by-minute.
    (if (= exp 0)
      PRECISION
      (assign
        squared (/ (* base base) PRECISION)
        recur (pow-discount squared (/ exp 2))
        (if (= (% exp TWO) ONE)
          (/ (* recur base) PRECISION)
          recur
        )
      )
    )
  )

  (defun-inline calculate-cumulative-discount-factor (past current current_timestamp previous_timestamp)
    ;; Computes: past * (current / PRECISION)^(minutes elapsed).
    ;; Uses pow-discount to avoid per-minute recursion while keeping rounding consistent.
    (assign
      (quotient . remainder) (divmod previous_timestamp ONE_MINUTE)
      start_timestamp (+ previous_timestamp (- ONE_MINUTE remainder))
      raw_elapsed (- current_timestamp start_timestamp)
      elapsed_minutes (if (> raw_elapsed MINUS_ONE) (+ (/ raw_elapsed ONE_MINUTE) ONE) 0)
      multiplier (pow-discount current elapsed_minutes)
      (/ (* past multiplier) PRECISION)
    )
  )

  (defun-inline is-approval-mod (approval_mod_hashes approval_mod)
    (any
      (= (f approval_mod_hashes) approval_mod)
      (= (f (r approval_mod_hashes)) approval_mod)
      (= (f (r (r approval_mod_hashes))) approval_mod)
      (= (f (r (r (r approval_mod_hashes)))) approval_mod)
      (= (f (r (r (r (r approval_mod_hashes))))) approval_mod)
    )
  )


  (defun contains (lst item)
    (if lst
      (if (= (f lst) item)
        ONE
        (contains (r lst) item)
      )
      ; not found
      ()
    )
  )

  (defun assert_debug_ (items)
    (if (r items)
      (qq (if (unquote (f items)) (unquote (assert_debug_ (r items))) (x (unquote (c 1 (f items))))))
      (f items)
    )
  )

  ; this also shows which part of assert failed
  (defmac assert_debug items (assert_debug_ items))

  (defun assert_ (items)
    (if (r items)
      (qq (if (unquote (f items)) (unquote (assert_ (r items))) (x)))
      (f items)
      )
    )

  (defmac assert items (assert_ items))

  (defun sha256tree (TREE)
    (if (l TREE)
      (sha256 TWO (sha256tree (f TREE)) (sha256tree (r TREE)))
      (sha256 ONE TREE)
    )
  )

  (defun merge-lists (list_a list_b)
    (if list_a
      (c
        (f list_a)
        (merge-lists
          (r list_a)
          list_b)
        )
      list_b
    )
  )

  (defun print (to-show result) (if (all "$print$" to-show result) result result))

  (defun-inline li x x)
)
